<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>3D ì¥ì• ë¬¼ í”¼í•˜ê¸° ê²Œì„</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #1a1a1a;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
      touch-action: pan-x; /* ìˆ˜í‰ ìŠ¤ì™€ì´í”„ë§Œ í—ˆìš© */
      -webkit-touch-callout: none; /* iOSì—ì„œ í„°ì¹˜ ë©”ë‰´ ë¹„í™œì„±í™” */
      -webkit-user-select: none; /* í…ìŠ¤íŠ¸ ì„ íƒ ë¹„í™œì„±í™” */
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* ë©”ì¸ ë©”ë‰´ ìŠ¤íƒ€ì¼ */
    #mainMenu {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      font-size: 1.2em;
    }

    #mainMenu h1 {
      font-size: 3em;
      margin-bottom: 40px;
      color: #4CAF50;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .difficulty-section {
      margin: 30px 0;
      text-align: center;
    }

    .difficulty-section h2 {
      font-size: 1.5em;
      margin-bottom: 20px;
      color: #fff;
    }

    .difficulty-btn {
      margin: 10px;
      padding: 15px 30px;
      font-size: 1.2em;
      border: none;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .difficulty-btn.easy {
      background: linear-gradient(45deg, #4CAF50, #45a049);
    }

    .difficulty-btn.normal {
      background: linear-gradient(45deg, #FF9800, #F57C00);
    }

    .difficulty-btn.hard {
      background: linear-gradient(45deg, #F44336, #D32F2F);
    }

    .difficulty-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    .controls-section {
      margin: 30px 0;
      text-align: center;
    }

    .controls-section h2 {
      font-size: 1.5em;
      margin-bottom: 15px;
      color: #fff;
    }

    .controls-section p {
      margin: 5px 0;
      color: #ccc;
      font-size: 1em;
    }

    .high-score {
      margin: 30px 0;
      text-align: center;
    }

    .high-score h2 {
      font-size: 1.5em;
      margin-bottom: 10px;
      color: #fff;
    }

    .high-score .score {
      font-size: 2em;
      color: #FFD700;
      font-weight: bold;
    }

    /* HUD ìŠ¤íƒ€ì¼ */
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      right: 20px;
      z-index: 10;
      color: white;
      font-size: 1.2em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      display: none;
    }

    .hud-left {
      position: absolute;
      left: 0;
      top: 0;
    }

    .hud-right {
      position: absolute;
      right: 0;
      top: 0;
    }

    .hud-item {
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      margin: 5px;
      border-radius: 10px;
      display: inline-block;
    }

    #score {
      color: #FFD700;
    }

    #lives {
      color: #ff6b6b;
      font-size: 1.3em;
    }

    #speed {
      color: #4CAF50;
    }

    #distance {
      color: #2196F3;
    }

    #items {
      color: #9C27B0;
    }

    /* ê²Œì„ ì˜¤ë²„ í™”ë©´ */
    #gameOverScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
      font-size: 1.2em;
    }

    #gameOverScreen h1 {
      font-size: 3em;
      margin-bottom: 30px;
      color: #F44336;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .final-stats {
      text-align: center;
      margin: 20px 0;
    }

    .final-stats h2 {
      font-size: 1.5em;
      margin-bottom: 10px;
      color: #fff;
    }

    .final-stats .stat {
      margin: 5px 0;
      color: #ccc;
    }

    .final-stats .score {
      font-size: 2em;
      color: #FFD700;
      font-weight: bold;
    }

    .new-record {
      color: #4CAF50;
      font-size: 1.5em;
      font-weight: bold;
      margin: 20px 0;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .restart-btn {
      margin: 20px;
      padding: 15px 30px;
      font-size: 1.2em;
      background: linear-gradient(45deg, #4CAF50, #45a049);
      border: none;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .restart-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    /* ì¼ì‹œì •ì§€ í™”ë©´ */
    #pauseScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 150;
      font-size: 1.2em;
    }

    #pauseScreen h1 {
      font-size: 3em;
      margin-bottom: 30px;
      color: #FF9800;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .pause-btn {
      margin: 10px;
      padding: 15px 30px;
      font-size: 1.2em;
      background: linear-gradient(45deg, #2196F3, #1976D2);
      border: none;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .pause-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    /* ì¡°ì‘ë²• ì•ˆë‚´ */
    #controlsInfo {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 15px;
      border-radius: 10px;
      font-size: 0.9em;
      z-index: 10;
      display: none;
    }

    /* í„°ì¹˜ í”¼ë“œë°± */
    .touch-feedback {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.8);
      color: #333;
      padding: 20px 30px;
      border-radius: 15px;
      font-size: 1.5em;
      font-weight: bold;
      z-index: 200;
      pointer-events: none;
      animation: touchFeedback 0.5s ease-out;
    }

    @keyframes touchFeedback {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.5); 
      }
      50% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.1); 
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(1); 
      }
    }

    /* ë¡œë”© í™”ë©´ */
    #loadingScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #1a1a1a;
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 300;
      font-size: 1.5em;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #333;
      border-top: 5px solid #4CAF50;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- ë¡œë”© í™”ë©´ -->
  <div id="loadingScreen">
    <div class="loading-spinner"></div>
    <div>ê²Œì„ì„ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤...</div>
  </div>

  <!-- ë©”ì¸ ë©”ë‰´ -->
  <div id="mainMenu">
    <h1>ğŸƒâ€â™‚ï¸ ì¥ì• ë¬¼ í”¼í•˜ê¸° ê²Œì„</h1>
    
    <div class="difficulty-section">
      <h2>ë‚œì´ë„ ì„ íƒ</h2>
      <button class="difficulty-btn easy" onclick="startGame('easy')">ì‰¬ì›€</button>
      <button class="difficulty-btn normal" onclick="startGame('normal')">ë³´í†µ</button>
      <button class="difficulty-btn hard" onclick="startGame('hard')">ì–´ë ¤ì›€</button>
    </div>

    <div class="controls-section">
      <h2>ì¡°ì‘ë²•</h2>
      <p>â† â†’ ë˜ëŠ” A D : ì¢Œìš° ì´ë™</p>
      <p>ESC : ì¼ì‹œì •ì§€</p>
      <p>R : ì¬ì‹œì‘</p>
      <p>ğŸ“± ëª¨ë°”ì¼: ì¢Œìš° ìŠ¤ì™€ì´í”„ë¡œ ì´ë™</p>
    </div>

    <div class="high-score">
      <h2>ìµœê³  ì ìˆ˜</h2>
      <div class="score" id="highScoreDisplay">0ì </div>
    </div>
  </div>

  <!-- ê²Œì„ ì»¨í…Œì´ë„ˆ -->
  <div id="gameContainer">
    <!-- HUD -->
    <div id="hud">
      <div class="hud-left">
        <div class="hud-item" id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
        <div class="hud-item" id="speed">ì†ë„: 1.0x</div>
        <div class="hud-item" id="distance">ê±°ë¦¬: 0m</div>
      </div>
      <div class="hud-right">
        <div class="hud-item" id="score">ì ìˆ˜: 0</div>
        <div class="hud-item" id="items">ì•„ì´í…œ: ì—†ìŒ</div>
      </div>
    </div>

    <!-- ì¡°ì‘ë²• ì•ˆë‚´ -->
    <div id="controlsInfo">
      <div>â† â†’ : ì´ë™ | ESC : ì¼ì‹œì •ì§€ | R : ì¬ì‹œì‘ | ğŸ“± ìŠ¤ì™€ì´í”„</div>
      <div>í˜„ì¬ ë ˆì¸: <span id="currentLane">ì¤‘ì•™</span></div>
    </div>
  </div>

  <!-- ì¼ì‹œì •ì§€ í™”ë©´ -->
  <div id="pauseScreen">
    <h1>ì¼ì‹œì •ì§€</h1>
    <button class="pause-btn" onclick="resumeGame()">ê²Œì„ ì¬ê°œ (ESC)</button>
    <button class="pause-btn" onclick="showMainMenu()">ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°</button>
  </div>

  <!-- ê²Œì„ ì˜¤ë²„ í™”ë©´ -->
  <div id="gameOverScreen">
    <h1>ê²Œì„ ì˜¤ë²„</h1>
    <div class="final-stats">
      <h2>ìµœì¢… ì ìˆ˜</h2>
      <div class="score" id="finalScore">0ì </div>
    </div>
    <div class="final-stats">
      <h2>ìƒì¡´ ì‹œê°„</h2>
      <div class="stat" id="survivalTime">0ë¶„ 0ì´ˆ</div>
    </div>
    <div class="final-stats">
      <h2>ìˆ˜ì§‘ ì•„ì´í…œ</h2>
      <div class="stat" id="collectedItems">ì½”ì¸: 0ê°œ | í•˜íŠ¸: 0ê°œ | ì‹¤ë“œ: 0ê°œ</div>
    </div>
    <div class="new-record" id="newRecord" style="display: none;">ğŸ‰ ìƒˆë¡œìš´ ìµœê³  ì ìˆ˜! ğŸ‰</div>
    <button class="restart-btn" onclick="showMainMenu()">ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°</button>
  </div>

  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // ê²Œì„ ì „ì—­ ë³€ìˆ˜
    let scene, camera, renderer, gameContainer;
    let player, obstacles = [], items = [];
    let gameState = 'menu'; // menu, playing, paused, gameOver
    let currentDifficulty = 'normal';
    let currentLane = 1; // 0: ì¢Œì¸¡, 1: ì¤‘ì•™, 2: ìš°ì¸¡
    let gameSpeed = 0.1;
    let score = 0;
    let lives = 3;
    let distance = 0;
    let gameStartTime = 0;
    let lastObstacleTime = 0;
    let lastItemTime = 0;
    let activeItems = {};
    let collectedItems = { coin: 0, heart: 0, shield: 0, speed: 0, magnet: 0, slow: 0 };
    let highScore = 0;

    // ë‚œì´ë„ë³„ ì„¤ì •
    const difficultySettings = {
      easy: {
        speed: 0.08,
        obstacleInterval: [2000, 4000],
        itemChance: 0.3,
        obstacleTypes: ['tree', 'rock']
      },
      normal: {
        speed: 0.12,
        obstacleInterval: [1500, 3000],
        itemChance: 0.25,
        obstacleTypes: ['tree', 'rock', 'hole', 'moving']
      },
      hard: {
        speed: 0.16,
        obstacleInterval: [1000, 2000],
        itemChance: 0.2,
        obstacleTypes: ['tree', 'rock', 'hole', 'moving', 'continuous']
      }
    };

    // ë ˆì¸ ìœ„ì¹˜ (x ì¢Œí‘œ)
    const lanePositions = [-200, 0, 200];

    // ì´ˆê¸°í™”
    function init() {
      // ë¡œë”© í™”ë©´ ìˆ¨ê¸°ê¸°
      document.getElementById('loadingScreen').style.display = 'none';
      
      // ìµœê³  ì ìˆ˜ ë¡œë“œ
      loadHighScore();
      
      // Three.js ì´ˆê¸°í™”
      initThreeJS();
      
      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
      setupEventListeners();
      
      // ë©”ì¸ ë©”ë‰´ í‘œì‹œ
      showMainMenu();
    }

    // Three.js ì´ˆê¸°í™”
    function initThreeJS() {
      gameContainer = document.getElementById('gameContainer');
      
      // ì”¬ ìƒì„±
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB); // í•˜ëŠ˜ìƒ‰
      
      // ì¹´ë©”ë¼ ìƒì„±
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 100, 200);
      camera.lookAt(0, 0, 0);
      
      // ë Œë”ëŸ¬ ìƒì„±
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      gameContainer.appendChild(renderer.domElement);
      
      // ì¡°ëª… ì„¤ì •
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // ë„ë¡œ ìƒì„±
      createRoad();
      
      // í”Œë ˆì´ì–´ ìƒì„±
      createPlayer();
      
      // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ì‹œì‘
      animate();
    }

    // ë„ë¡œ ìƒì„±
    function createRoad() {
      // ë©”ì¸ ë„ë¡œ
      const roadGeometry = new THREE.PlaneGeometry(600, 2000);
      const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const road = new THREE.Mesh(roadGeometry, roadMaterial);
      road.rotation.x = -Math.PI / 2;
      road.position.y = -1;
      road.receiveShadow = true;
      scene.add(road);
      
      // ë„ë¡œ ì¤‘ì•™ì„ 
      for (let i = 0; i < 20; i++) {
        const lineGeometry = new THREE.PlaneGeometry(4, 20);
        const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
        const line = new THREE.Mesh(lineGeometry, lineMaterial);
        line.rotation.x = -Math.PI / 2;
        line.position.set(0, -0.5, -i * 100);
        scene.add(line);
      }
      
      // ë ˆì¸ êµ¬ë¶„ì„ 
      for (let lane = 0; lane < 2; lane++) {
        for (let i = 0; i < 20; i++) {
          const lineGeometry = new THREE.PlaneGeometry(2, 10);
          const lineMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
          const line = new THREE.Mesh(lineGeometry, lineMaterial);
          line.rotation.x = -Math.PI / 2;
          line.position.set(lanePositions[lane] + 100, -0.4, -i * 100 + 5);
          scene.add(line);
        }
      }
    }

    // í”Œë ˆì´ì–´ ìƒì„±
    function createPlayer() {
      const playerGeometry = new THREE.BoxGeometry(40, 60, 30);
      const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
      player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.position.set(0, 30, 0);
      player.castShadow = true;
      scene.add(player);
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    function setupEventListeners() {
      // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      
      // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼ ì§€ì›)
      document.addEventListener('touchstart', handleTouchStart, { passive: false });
      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (ë°ìŠ¤í¬í†±ì—ì„œë„ í„°ì¹˜ ìŠ¤íƒ€ì¼ ì¡°ì‘ ì§€ì›)
      document.addEventListener('mousedown', handleMouseDown);
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
      window.addEventListener('resize', onWindowResize);
    }

    // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
    function handleKeyDown(event) {
      if (gameState === 'playing') {
        switch(event.code) {
          case 'ArrowLeft':
          case 'KeyA':
            movePlayer(-1);
            break;
          case 'ArrowRight':
          case 'KeyD':
            movePlayer(1);
            break;
          case 'Escape':
            pauseGame();
            break;
          case 'KeyR':
            restartGame();
            break;
        }
      } else if (gameState === 'paused') {
        if (event.code === 'Escape') {
          resumeGame();
        }
      }
    }

    function handleKeyUp(event) {
      // í•„ìš”ì‹œ í‚¤ ì—… ì´ë²¤íŠ¸ ì²˜ë¦¬
    }

    // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì¡°ì‘ì„ ìœ„í•œ ì „ì—­ ë³€ìˆ˜
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    let isDragging = false;
    let minSwipeDistance = 50; // ìµœì†Œ ìŠ¤ì™€ì´í”„ ê±°ë¦¬

    // í„°ì¹˜ ì‹œì‘
    function handleTouchStart(event) {
      if (gameState !== 'playing') return;
      
      event.preventDefault();
      const touch = event.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      isDragging = true;
    }

    // í„°ì¹˜ ì´ë™
    function handleTouchMove(event) {
      if (gameState !== 'playing' || !isDragging) return;
      
      event.preventDefault();
      const touch = event.touches[0];
      touchEndX = touch.clientX;
      touchEndY = touch.clientY;
    }

    // í„°ì¹˜ ì¢…ë£Œ
    function handleTouchEnd(event) {
      if (gameState !== 'playing' || !isDragging) return;
      
      event.preventDefault();
      isDragging = false;
      
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      // ìˆ˜ì§ ìŠ¤ì™€ì´í”„ê°€ ìˆ˜í‰ ìŠ¤ì™€ì´í”„ë³´ë‹¤ í¬ë©´ ë¬´ì‹œ (ì„¸ë¡œ ìŠ¤í¬ë¡¤ ë°©ì§€)
      if (Math.abs(deltaY) > Math.abs(deltaX)) {
        return;
      }
      
      // ìµœì†Œ ìŠ¤ì™€ì´í”„ ê±°ë¦¬ ì²´í¬
      if (Math.abs(deltaX) < minSwipeDistance) {
        return;
      }
      
      // ì¢Œìš° ìŠ¤ì™€ì´í”„ ì²˜ë¦¬
      if (deltaX > 0) {
        // ì˜¤ë¥¸ìª½ ìŠ¤ì™€ì´í”„ - ì˜¤ë¥¸ìª½ ë ˆì¸ìœ¼ë¡œ ì´ë™
        movePlayer(1);
        showTouchFeedback('â†’');
      } else {
        // ì™¼ìª½ ìŠ¤ì™€ì´í”„ - ì™¼ìª½ ë ˆì¸ìœ¼ë¡œ ì´ë™
        movePlayer(-1);
        showTouchFeedback('â†');
      }
    }

    // ë§ˆìš°ìŠ¤ ë‹¤ìš´
    function handleMouseDown(event) {
      if (gameState !== 'playing') return;
      
      touchStartX = event.clientX;
      touchStartY = event.clientY;
      isDragging = true;
    }

    // ë§ˆìš°ìŠ¤ ì´ë™
    function handleMouseMove(event) {
      if (gameState !== 'playing' || !isDragging) return;
      
      touchEndX = event.clientX;
      touchEndY = event.clientY;
    }

    // ë§ˆìš°ìŠ¤ ì—…
    function handleMouseUp(event) {
      if (gameState !== 'playing' || !isDragging) return;
      
      isDragging = false;
      
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      
      // ìˆ˜ì§ ë“œë˜ê·¸ê°€ ìˆ˜í‰ ë“œë˜ê·¸ë³´ë‹¤ í¬ë©´ ë¬´ì‹œ
      if (Math.abs(deltaY) > Math.abs(deltaX)) {
        return;
      }
      
      // ìµœì†Œ ë“œë˜ê·¸ ê±°ë¦¬ ì²´í¬
      if (Math.abs(deltaX) < minSwipeDistance) {
        return;
      }
      
      // ì¢Œìš° ë“œë˜ê·¸ ì²˜ë¦¬
      if (deltaX > 0) {
        // ì˜¤ë¥¸ìª½ ë“œë˜ê·¸ - ì˜¤ë¥¸ìª½ ë ˆì¸ìœ¼ë¡œ ì´ë™
        movePlayer(1);
        showTouchFeedback('â†’');
      } else {
        // ì™¼ìª½ ë“œë˜ê·¸ - ì™¼ìª½ ë ˆì¸ìœ¼ë¡œ ì´ë™
        movePlayer(-1);
        showTouchFeedback('â†');
      }
    }

    // í”Œë ˆì´ì–´ ì´ë™
    function movePlayer(direction) {
      const newLane = currentLane + direction;
      if (newLane >= 0 && newLane <= 2) {
        currentLane = newLane;
        const targetX = lanePositions[currentLane];
        
        // ë¶€ë“œëŸ¬ìš´ ì´ë™ ì• ë‹ˆë©”ì´ì…˜
        const startX = player.position.x;
        const duration = 200; // 200ms
        const startTime = Date.now();
        
        function animateMove() {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const easeProgress = 1 - Math.pow(1 - progress, 3); // ease-out
          
          player.position.x = startX + (targetX - startX) * easeProgress;
          
          if (progress < 1) {
            requestAnimationFrame(animateMove);
          }
        }
        
        animateMove();
        updateLaneDisplay();
      }
    }

    // ë ˆì¸ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateLaneDisplay() {
      const laneNames = ['ì¢Œì¸¡', 'ì¤‘ì•™', 'ìš°ì¸¡'];
      document.getElementById('currentLane').textContent = laneNames[currentLane];
    }

    // í„°ì¹˜ í”¼ë“œë°± í‘œì‹œ
    function showTouchFeedback(direction) {
      const feedback = document.createElement('div');
      feedback.className = 'touch-feedback';
      feedback.textContent = direction;
      document.body.appendChild(feedback);
      
      setTimeout(() => {
        if (document.body.contains(feedback)) {
          document.body.removeChild(feedback);
        }
      }, 500);
    }

    // ê²Œì„ ì‹œì‘
    function startGame(difficulty) {
      currentDifficulty = difficulty;
      gameState = 'playing';
      gameStartTime = Date.now();
      
      // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
      score = 0;
      lives = 3;
      distance = 0;
      currentLane = 1;
      player.position.x = 0;
      activeItems = {};
      collectedItems = { coin: 0, heart: 0, shield: 0, speed: 0, magnet: 0, slow: 0 };
      
      // ê¸°ì¡´ ì¥ì• ë¬¼ê³¼ ì•„ì´í…œ ì œê±°
      clearObstacles();
      clearItems();
      
      // UI ì—…ë°ì´íŠ¸
      document.getElementById('mainMenu').style.display = 'none';
      document.getElementById('hud').style.display = 'block';
      document.getElementById('controlsInfo').style.display = 'block';
      document.getElementById('gameOverScreen').style.display = 'none';
      document.getElementById('pauseScreen').style.display = 'none';
      
      updateHUD();
      updateLaneDisplay();
    }

    // ê²Œì„ ì¼ì‹œì •ì§€
    function pauseGame() {
      if (gameState === 'playing') {
        gameState = 'paused';
        document.getElementById('pauseScreen').style.display = 'flex';
      }
    }

    // ê²Œì„ ì¬ê°œ
    function resumeGame() {
      if (gameState === 'paused') {
        gameState = 'playing';
        document.getElementById('pauseScreen').style.display = 'none';
      }
    }

    // ê²Œì„ ì¬ì‹œì‘
    function restartGame() {
      startGame(currentDifficulty);
    }

    // ë©”ì¸ ë©”ë‰´ í‘œì‹œ
    function showMainMenu() {
      gameState = 'menu';
      document.getElementById('mainMenu').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('controlsInfo').style.display = 'none';
      document.getElementById('gameOverScreen').style.display = 'none';
      document.getElementById('pauseScreen').style.display = 'none';
      
      // ê¸°ì¡´ ì¥ì• ë¬¼ê³¼ ì•„ì´í…œ ì œê±°
      clearObstacles();
      clearItems();
    }

    // ê²Œì„ ì˜¤ë²„
    function gameOver() {
      gameState = 'gameOver';
      
      // ìµœì¢… í†µê³„ ê³„ì‚°
      const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
      const minutes = Math.floor(survivalTime / 60);
      const seconds = survivalTime % 60;
      
      // UI ì—…ë°ì´íŠ¸
      document.getElementById('finalScore').textContent = score + 'ì ';
      document.getElementById('survivalTime').textContent = minutes + 'ë¶„ ' + seconds + 'ì´ˆ';
      document.getElementById('collectedItems').textContent = 
        `ì½”ì¸: ${collectedItems.coin}ê°œ | í•˜íŠ¸: ${collectedItems.heart}ê°œ | ì‹¤ë“œ: ${collectedItems.shield}ê°œ`;
      
      // ìµœê³  ì ìˆ˜ í™•ì¸
      if (score > highScore) {
        highScore = score;
        saveHighScore();
        document.getElementById('newRecord').style.display = 'block';
      } else {
        document.getElementById('newRecord').style.display = 'none';
      }
      
      document.getElementById('gameOverScreen').style.display = 'flex';
      document.getElementById('hud').style.display = 'none';
      document.getElementById('controlsInfo').style.display = 'none';
    }

    // HUD ì—…ë°ì´íŠ¸
    function updateHUD() {
      document.getElementById('score').textContent = 'ì ìˆ˜: ' + score;
      document.getElementById('lives').textContent = 'â¤ï¸'.repeat(lives);
      document.getElementById('speed').textContent = 'ì†ë„: ' + (gameSpeed / 0.1).toFixed(1) + 'x';
      document.getElementById('distance').textContent = 'ê±°ë¦¬: ' + Math.floor(distance) + 'm';
      
      // í™œì„± ì•„ì´í…œ í‘œì‹œ
      const activeItemTexts = [];
      if (activeItems.shield) activeItemTexts.push('ğŸ›¡ï¸ ì‹¤ë“œ');
      if (activeItems.speed) activeItemTexts.push('âš¡ ìŠ¤í”¼ë“œ');
      if (activeItems.magnet) activeItemTexts.push('ğŸ§² ìì„');
      if (activeItems.slow) activeItemTexts.push('ğŸŒ ìŠ¬ë¡œìš°');
      
      document.getElementById('items').textContent = 'ì•„ì´í…œ: ' + 
        (activeItemTexts.length > 0 ? activeItemTexts.join(', ') : 'ì—†ìŒ');
    }

    // ì¥ì• ë¬¼ ì œê±°
    function clearObstacles() {
      obstacles.forEach(obstacle => {
        scene.remove(obstacle);
      });
      obstacles = [];
    }

    // ì•„ì´í…œ ì œê±°
    function clearItems() {
      items.forEach(item => {
        scene.remove(item);
      });
      items = [];
    }

    // ìµœê³  ì ìˆ˜ ë¡œë“œ
    function loadHighScore() {
      const saved = localStorage.getItem('obstacleGame_highScore');
      highScore = saved ? parseInt(saved) : 0;
      document.getElementById('highScoreDisplay').textContent = highScore + 'ì ';
    }

    // ìµœê³  ì ìˆ˜ ì €ì¥
    function saveHighScore() {
      localStorage.setItem('obstacleGame_highScore', highScore.toString());
      document.getElementById('highScoreDisplay').textContent = highScore + 'ì ';
    }

    // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);
      
      if (gameState === 'playing') {
        updateGame();
      }
      
      renderer.render(scene, camera);
    }

    // ê²Œì„ ì—…ë°ì´íŠ¸
    function updateGame() {
      const currentTime = Date.now();
      
      // ê±°ë¦¬ ì—…ë°ì´íŠ¸
      distance += gameSpeed * 2;
      
      // ì ìˆ˜ ì—…ë°ì´íŠ¸ (ê±°ë¦¬ ê¸°ë°˜)
      score += Math.floor(gameSpeed * 10);
      
      // ì¥ì• ë¬¼ ìƒì„±
      const settings = difficultySettings[currentDifficulty];
      if (currentTime - lastObstacleTime > 
          Math.random() * (settings.obstacleInterval[1] - settings.obstacleInterval[0]) + settings.obstacleInterval[0]) {
        createObstacle();
        lastObstacleTime = currentTime;
      }
      
      // ì•„ì´í…œ ìƒì„±
      if (Math.random() < settings.itemChance && 
          currentTime - lastItemTime > 3000) {
        createItem();
        lastItemTime = currentTime;
      }
      
      // ì¥ì• ë¬¼ ì´ë™ ë° ì¶©ëŒ ê²€ì‚¬
      updateObstacles();
      
      // ì•„ì´í…œ ì´ë™ ë° ìˆ˜ì§‘ ê²€ì‚¬
      updateItems();
      
      // ì•„ì´í…œ íš¨ê³¼ ì—…ë°ì´íŠ¸
      updateItemEffects();
      
      // HUD ì—…ë°ì´íŠ¸
      updateHUD();
      
      // ì ì§„ì  ë‚œì´ë„ ì¦ê°€
      gameSpeed = settings.speed * (1 + distance / 10000);
    }

    // ì¥ì• ë¬¼ ìƒì„±
    function createObstacle() {
      const settings = difficultySettings[currentDifficulty];
      const obstacleType = settings.obstacleTypes[Math.floor(Math.random() * settings.obstacleTypes.length)];
      const lane = Math.floor(Math.random() * 3);
      
      let obstacle;
      
      switch(obstacleType) {
        case 'tree':
          obstacle = createTreeObstacle();
          break;
        case 'rock':
          obstacle = createRockObstacle();
          break;
        case 'hole':
          obstacle = createHoleObstacle();
          break;
        case 'moving':
          obstacle = createMovingObstacle();
          break;
        case 'continuous':
          obstacle = createContinuousObstacle();
          break;
        default:
          obstacle = createTreeObstacle();
      }
      
      obstacle.position.set(lanePositions[lane], 0, -300);
      obstacle.userData = {
        type: obstacleType,
        lane: lane,
        speed: gameSpeed,
        isMoving: obstacleType === 'moving'
      };
      
      scene.add(obstacle);
      obstacles.push(obstacle);
    }

    // ë‚˜ë¬´ ì¥ì• ë¬¼ ìƒì„±
    function createTreeObstacle() {
      const group = new THREE.Group();
      
      // ë‚˜ë¬´ ì¤„ê¸°
      const trunkGeometry = new THREE.CylinderGeometry(8, 12, 40, 8);
      const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 20;
      trunk.castShadow = true;
      group.add(trunk);
      
      // ë‚˜ë¬´ ì
      const leavesGeometry = new THREE.SphereGeometry(25, 8, 6);
      const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves.position.y = 50;
      leaves.castShadow = true;
      group.add(leaves);
      
      return group;
    }

    // ë°”ìœ„ ì¥ì• ë¬¼ ìƒì„±
    function createRockObstacle() {
      const group = new THREE.Group();
      
      // ë©”ì¸ ë°”ìœ„
      const rockGeometry = new THREE.DodecahedronGeometry(20, 0);
      const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
      const rock = new THREE.Mesh(rockGeometry, rockMaterial);
      rock.position.y = 20;
      rock.castShadow = true;
      group.add(rock);
      
      // ì‘ì€ ë°”ìœ„ë“¤
      for (let i = 0; i < 3; i++) {
        const smallRockGeometry = new THREE.DodecahedronGeometry(8, 0);
        const smallRock = new THREE.Mesh(smallRockGeometry, rockMaterial);
        smallRock.position.set(
          (Math.random() - 0.5) * 40,
          8,
          (Math.random() - 0.5) * 40
        );
        smallRock.castShadow = true;
        group.add(smallRock);
      }
      
      return group;
    }

    // í•¨ì • ì¥ì• ë¬¼ ìƒì„±
    function createHoleObstacle() {
      const group = new THREE.Group();
      
      // êµ¬ë© (íˆ¬ëª…í•œ ì›ê¸°ë‘¥)
      const holeGeometry = new THREE.CylinderGeometry(30, 30, 5, 16);
      const holeMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x000000, 
        transparent: true, 
        opacity: 0.8 
      });
      const hole = new THREE.Mesh(holeGeometry, holeMaterial);
      hole.position.y = -2.5;
      group.add(hole);
      
      // êµ¬ë© ê°€ì¥ìë¦¬
      const edgeGeometry = new THREE.CylinderGeometry(32, 32, 2, 16);
      const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
      edge.position.y = -1;
      group.add(edge);
      
      return group;
    }

    // ì´ë™ ì¥ì• ë¬¼ ìƒì„±
    function createMovingObstacle() {
      const group = new THREE.Group();
      
      // ì›€ì§ì´ëŠ” ë‚˜ë¬´
      const trunkGeometry = new THREE.CylinderGeometry(6, 8, 30, 8);
      const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 15;
      trunk.castShadow = true;
      group.add(trunk);
      
      const leavesGeometry = new THREE.SphereGeometry(18, 8, 6);
      const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves.position.y = 35;
      leaves.castShadow = true;
      group.add(leaves);
      
      // ì´ë™ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
      group.userData.moveDirection = Math.random() > 0.5 ? 1 : -1;
      group.userData.moveSpeed = 0.5 + Math.random() * 0.5;
      
      return group;
    }

    // ì—°ì† ì¥ì• ë¬¼ ìƒì„±
    function createContinuousObstacle() {
      const group = new THREE.Group();
      
      // 3ê°œ ë ˆì¸ì— ì—°ì†ìœ¼ë¡œ ì¥ì• ë¬¼ ë°°ì¹˜
      for (let i = 0; i < 3; i++) {
        const obstacle = createTreeObstacle();
        obstacle.position.set(lanePositions[i], 0, 0);
        group.add(obstacle);
      }
      
      return group;
    }

    // ì•„ì´í…œ ìƒì„±
    function createItem() {
      const itemTypes = ['coin', 'heart', 'shield', 'speed', 'magnet', 'slow'];
      const itemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      const lane = Math.floor(Math.random() * 3);
      
      let item;
      
      switch(itemType) {
        case 'coin':
          item = createCoinItem();
          break;
        case 'heart':
          item = createHeartItem();
          break;
        case 'shield':
          item = createShieldItem();
          break;
        case 'speed':
          item = createSpeedItem();
          break;
        case 'magnet':
          item = createMagnetItem();
          break;
        case 'slow':
          item = createSlowItem();
          break;
      }
      
      item.position.set(lanePositions[lane], 20, -300);
      item.userData = {
        type: itemType,
        lane: lane,
        speed: gameSpeed,
        collected: false
      };
      
      scene.add(item);
      items.push(item);
    }

    // ì½”ì¸ ì•„ì´í…œ ìƒì„±
    function createCoinItem() {
      const group = new THREE.Group();
      
      // ì½”ì¸ ë³¸ì²´
      const coinGeometry = new THREE.CylinderGeometry(15, 15, 3, 16);
      const coinMaterial = new THREE.MeshLambertMaterial({ color: 0xFFD700 });
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.rotation.x = Math.PI / 2;
      coin.castShadow = true;
      group.add(coin);
      
      // ì½”ì¸ í…Œë‘ë¦¬
      const edgeGeometry = new THREE.CylinderGeometry(16, 16, 1, 16);
      const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFA500 });
      const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
      edge.rotation.x = Math.PI / 2;
      group.add(edge);
      
      return group;
    }

    // í•˜íŠ¸ ì•„ì´í…œ ìƒì„±
    function createHeartItem() {
      const group = new THREE.Group();
      
      // í•˜íŠ¸ ëª¨ì–‘ (ê°„ë‹¨í•œ êµ¬ì²´ë¡œ ëŒ€ì²´)
      const heartGeometry = new THREE.SphereGeometry(12, 8, 6);
      const heartMaterial = new THREE.MeshLambertMaterial({ color: 0xff6b6b });
      const heart = new THREE.Mesh(heartGeometry, heartMaterial);
      heart.castShadow = true;
      group.add(heart);
      
      return group;
    }

    // ì‹¤ë“œ ì•„ì´í…œ ìƒì„±
    function createShieldItem() {
      const group = new THREE.Group();
      
      // ì‹¤ë“œ ë³¸ì²´
      const shieldGeometry = new THREE.CylinderGeometry(12, 12, 2, 8);
      const shieldMaterial = new THREE.MeshLambertMaterial({ color: 0x2196F3 });
      const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
      shield.rotation.x = Math.PI / 2;
      shield.castShadow = true;
      group.add(shield);
      
      // ì‹¤ë“œ í…Œë‘ë¦¬
      const edgeGeometry = new THREE.CylinderGeometry(13, 13, 1, 8);
      const edgeMaterial = new THREE.MeshLambertMaterial({ color: 0x1976D2 });
      const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
      edge.rotation.x = Math.PI / 2;
      group.add(edge);
      
      return group;
    }

    // ìŠ¤í”¼ë“œ ë¶€ìŠ¤íŠ¸ ì•„ì´í…œ ìƒì„±
    function createSpeedItem() {
      const group = new THREE.Group();
      
      // ë²ˆê°œ ëª¨ì–‘ (ê°„ë‹¨í•œ êµ¬ì²´ë¡œ ëŒ€ì²´)
      const speedGeometry = new THREE.SphereGeometry(10, 8, 6);
      const speedMaterial = new THREE.MeshLambertMaterial({ color: 0xF44336 });
      const speed = new THREE.Mesh(speedGeometry, speedMaterial);
      speed.castShadow = true;
      group.add(speed);
      
      return group;
    }

    // ìì„ ì•„ì´í…œ ìƒì„±
    function createMagnetItem() {
      const group = new THREE.Group();
      
      // ìì„ ëª¨ì–‘ (ê°„ë‹¨í•œ êµ¬ì²´ë¡œ ëŒ€ì²´)
      const magnetGeometry = new THREE.SphereGeometry(10, 8, 6);
      const magnetMaterial = new THREE.MeshLambertMaterial({ color: 0xFFC107 });
      const magnet = new THREE.Mesh(magnetGeometry, magnetMaterial);
      magnet.castShadow = true;
      group.add(magnet);
      
      return group;
    }

    // ìŠ¬ë¡œìš° ì•„ì´í…œ ìƒì„±
    function createSlowItem() {
      const group = new THREE.Group();
      
      // ìŠ¬ë¡œìš° ëª¨ì–‘ (ê°„ë‹¨í•œ êµ¬ì²´ë¡œ ëŒ€ì²´)
      const slowGeometry = new THREE.SphereGeometry(10, 8, 6);
      const slowMaterial = new THREE.MeshLambertMaterial({ color: 0x9C27B0 });
      const slow = new THREE.Mesh(slowGeometry, slowMaterial);
      slow.castShadow = true;
      group.add(slow);
      
      return group;
    }

    // ì¥ì• ë¬¼ ì—…ë°ì´íŠ¸
    function updateObstacles() {
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        
        // ì¥ì• ë¬¼ ì´ë™
        obstacle.position.z += obstacle.userData.speed * 100;
        
        // ì´ë™ ì¥ì• ë¬¼ì˜ ì¢Œìš° ì›€ì§ì„
        if (obstacle.userData.isMoving) {
          obstacle.position.x += obstacle.userData.moveDirection * obstacle.userData.moveSpeed;
          
          // ë ˆì¸ ê²½ê³„ì—ì„œ ë°©í–¥ ì „í™˜
          if (obstacle.position.x > 100 || obstacle.position.x < -100) {
            obstacle.userData.moveDirection *= -1;
          }
        }
        
        // í™”ë©´ì„ ë²—ì–´ë‚œ ì¥ì• ë¬¼ ì œê±°
        if (obstacle.position.z > 200) {
          scene.remove(obstacle);
          obstacles.splice(i, 1);
          continue;
        }
        
        // ì¶©ëŒ ê²€ì‚¬
        if (checkCollision(obstacle, player)) {
          handleCollision(obstacle);
        }
      }
    }

    // ì¶©ëŒ ê²€ì‚¬
    function checkCollision(obstacle, player) {
      const obstacleBox = new THREE.Box3().setFromObject(obstacle);
      const playerBox = new THREE.Box3().setFromObject(player);
      
      // Zì¶• ê±°ë¦¬ ì²´í¬ (í”Œë ˆì´ì–´ ì•ë’¤ë¡œ ì—¬ìœ  ê³µê°„)
      if (obstacleBox.min.z > playerBox.max.z + 20 || obstacleBox.max.z < playerBox.min.z - 20) {
        return false;
      }
      
      // Xì¶• ê±°ë¦¬ ì²´í¬ (ë ˆì¸ ì²´í¬)
      const obstacleLane = obstacle.userData.lane;
      const playerLane = currentLane;
      
      // ì—°ì† ì¥ì• ë¬¼ì˜ ê²½ìš° ëª¨ë“  ë ˆì¸ì—ì„œ ì¶©ëŒ ê°€ëŠ¥
      if (obstacle.userData.type === 'continuous') {
        return true;
      }
      
      // ê°™ì€ ë ˆì¸ì— ìˆìœ¼ë©´ ì¶©ëŒ
      return obstacleLane === playerLane;
    }

    // ì¶©ëŒ ì²˜ë¦¬
    function handleCollision(obstacle) {
      // ì‹¤ë“œ ì•„ì´í…œì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì¶©ëŒ ë¬´ì‹œ
      if (activeItems.shield) {
        return;
      }
      
      // ìƒëª… ê°ì†Œ
      lives--;
      
      // ì¶©ëŒ íš¨ê³¼ (í™”ë©´ í”ë“¤ë¦¼)
      shakeCamera();
      
      // ì¥ì• ë¬¼ ì œê±°
      scene.remove(obstacle);
      const index = obstacles.indexOf(obstacle);
      if (index > -1) {
        obstacles.splice(index, 1);
      }
      
      // ê²Œì„ ì˜¤ë²„ ì²´í¬
      if (lives <= 0) {
        gameOver();
      }
    }

    // ì¹´ë©”ë¼ í”ë“¤ë¦¼ íš¨ê³¼
    function shakeCamera() {
      const originalPosition = camera.position.clone();
      const shakeIntensity = 5;
      const shakeDuration = 200;
      const startTime = Date.now();
      
      function shake() {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / shakeDuration;
        
        if (progress < 1) {
          const intensity = shakeIntensity * (1 - progress);
          camera.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
          camera.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
          requestAnimationFrame(shake);
        } else {
          camera.position.copy(originalPosition);
        }
      }
      
      shake();
    }

    // ì•„ì´í…œ ì—…ë°ì´íŠ¸
    function updateItems() {
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        
        // ì•„ì´í…œ ì´ë™
        item.position.z += item.userData.speed * 100;
        
        // ìì„ ì•„ì´í…œì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ í”Œë ˆì´ì–´ ìª½ìœ¼ë¡œ ëŒì–´ë‹¹ê¹€
        if (activeItems.magnet) {
          const playerX = player.position.x;
          const itemX = item.position.x;
          const pullSpeed = 2;
          
          if (itemX < playerX) {
            item.position.x += pullSpeed;
          } else if (itemX > playerX) {
            item.position.x -= pullSpeed;
          }
        }
        
        // í™”ë©´ì„ ë²—ì–´ë‚œ ì•„ì´í…œ ì œê±°
        if (item.position.z > 200) {
          scene.remove(item);
          items.splice(i, 1);
          continue;
        }
        
        // ìˆ˜ì§‘ ê²€ì‚¬
        if (checkItemCollection(item, player)) {
          collectItem(item);
        }
      }
    }

    // ì•„ì´í…œ ìˆ˜ì§‘ ê²€ì‚¬
    function checkItemCollection(item, player) {
      const itemBox = new THREE.Box3().setFromObject(item);
      const playerBox = new THREE.Box3().setFromObject(player);
      
      // Zì¶• ê±°ë¦¬ ì²´í¬
      if (itemBox.min.z > playerBox.max.z + 20 || itemBox.max.z < playerBox.min.z - 20) {
        return false;
      }
      
      // Xì¶• ê±°ë¦¬ ì²´í¬ (ìì„ ì•„ì´í…œì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë” ë„“ì€ ë²”ìœ„)
      const collectionRange = activeItems.magnet ? 100 : 50;
      const distance = Math.abs(item.position.x - player.position.x);
      
      return distance < collectionRange;
    }

    // ì•„ì´í…œ ìˆ˜ì§‘ ì²˜ë¦¬
    function collectItem(item) {
      const itemType = item.userData.type;
      
      // ìˆ˜ì§‘ í†µê³„ ì—…ë°ì´íŠ¸
      collectedItems[itemType]++;
      
      // ì•„ì´í…œ íš¨ê³¼ ì ìš©
      switch(itemType) {
        case 'coin':
          score += 10;
          break;
        case 'heart':
          if (lives < 3) {
            lives++;
          }
          break;
        case 'shield':
          activateItem('shield', 3000); // 3ì´ˆ
          break;
        case 'speed':
          activateItem('speed', 5000); // 5ì´ˆ
          break;
        case 'magnet':
          activateItem('magnet', 5000); // 5ì´ˆ
          break;
        case 'slow':
          activateItem('slow', 5000); // 5ì´ˆ
          break;
      }
      
      // ì•„ì´í…œ ì œê±°
      scene.remove(item);
      const index = items.indexOf(item);
      if (index > -1) {
        items.splice(index, 1);
      }
      
      // ìˆ˜ì§‘ íš¨ê³¼ (í™”ë©´ ë°˜ì§ì„)
      flashScreen();
    }

    // ì•„ì´í…œ í™œì„±í™”
    function activateItem(itemType, duration) {
      activeItems[itemType] = Date.now() + duration;
    }

    // ì•„ì´í…œ íš¨ê³¼ ì—…ë°ì´íŠ¸
    function updateItemEffects() {
      const currentTime = Date.now();
      
      // ë§Œë£Œëœ ì•„ì´í…œ íš¨ê³¼ ì œê±°
      for (const itemType in activeItems) {
        if (activeItems[itemType] <= currentTime) {
          delete activeItems[itemType];
        }
      }
      
      // ìŠ¬ë¡œìš° ì•„ì´í…œ íš¨ê³¼ ì ìš©
      if (activeItems.slow) {
        // ì¥ì• ë¬¼ ì†ë„ ê°ì†Œ
        obstacles.forEach(obstacle => {
          obstacle.userData.speed = gameSpeed * 0.5;
        });
      } else {
        // ì •ìƒ ì†ë„ë¡œ ë³µì›
        obstacles.forEach(obstacle => {
          obstacle.userData.speed = gameSpeed;
        });
      }
    }

    // í™”ë©´ ë°˜ì§ì„ íš¨ê³¼
    function flashScreen() {
      const flashOverlay = document.createElement('div');
      flashOverlay.style.position = 'fixed';
      flashOverlay.style.top = '0';
      flashOverlay.style.left = '0';
      flashOverlay.style.width = '100vw';
      flashOverlay.style.height = '100vh';
      flashOverlay.style.background = 'rgba(255, 255, 255, 0.3)';
      flashOverlay.style.pointerEvents = 'none';
      flashOverlay.style.zIndex = '50';
      document.body.appendChild(flashOverlay);
      
      setTimeout(() => {
        document.body.removeChild(flashOverlay);
      }, 100);
    }


    // ê²Œì„ ì´ˆê¸°í™”
    window.addEventListener('load', init);
  </script>
</body>
</html>
