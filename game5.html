<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>3D íƒ€ìì—°ìŠµ ê²Œì„</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; background: #1a1a1a; font-family: 'Arial', sans-serif; }
    
    #gameContainer { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    
    /* ë©”ë‰´ ìŠ¤íƒ€ì¼ */
    #menu { 
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
      background: rgba(0, 0, 0, 0.9); color: white; 
      display: flex; flex-direction: column; justify-content: center; align-items: center; 
      z-index: 100; font-size: 1.2em;
    }
    #menu h1 { font-size: 3em; margin-bottom: 40px; color: #ff6b6b; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
    #menu p { font-size: 1.1em; margin-bottom: 30px; color: #ccc; }
    .difficulty-btn { 
      margin: 10px; padding: 15px 30px; font-size: 1.2em; 
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4); 
      border: none; border-radius: 25px; color: white; 
      cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .difficulty-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.4); }
    
    /* HUD ìŠ¤íƒ€ì¼ */
    #hud { 
      position: fixed; top: 20px; left: 20px; right: 20px; 
      display: flex; justify-content: space-between; align-items: center; 
      z-index: 10; color: white; font-size: 1.3em; font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    }
    #score { color: #4ecdc4; }
    #lives { color: #ff6b6b; font-size: 1.5em; }
    #kills { color: #ffd93d; }
    
    /* ì…ë ¥ì°½ ìŠ¤íƒ€ì¼ */
    #inputArea { 
      position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); 
      z-index: 10; text-align: center;
    }
    #currentInput { 
      background: rgba(0, 0, 0, 0.8); color: white; 
      border: 2px solid #4ecdc4; border-radius: 15px; 
      padding: 15px 25px; font-size: 1.4em; 
      text-align: center; min-width: 300px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    #inputLabel { 
      color: #4ecdc4; font-size: 1.1em; margin-bottom: 10px; 
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    }
    
    /* ê²Œì„ ì˜¤ë²„ í™”ë©´ */
    #gameOver { 
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; 
      background: rgba(0, 0, 0, 0.9); color: white; 
      display: none; flex-direction: column; justify-content: center; align-items: center; 
      z-index: 100; font-size: 1.3em;
    }
    #gameOver h2 { font-size: 3em; margin-bottom: 30px; color: #ff6b6b; }
    #finalStats { margin-bottom: 30px; text-align: center; }
    #restartBtn { 
      padding: 15px 40px; font-size: 1.2em; 
      background: linear-gradient(45deg, #4ecdc4, #44a08d); 
      border: none; border-radius: 25px; color: white; 
      cursor: pointer; transition: all 0.3s;
    }
    #restartBtn:hover { transform: translateY(-2px); }
    
    /* ì¡°ì‘ë²• ì•ˆë‚´ */
    #instructions { 
      position: fixed; bottom: 10px; left: 10px; 
      color: rgba(255, 255, 255, 0.7); font-size: 0.9em; 
      z-index: 5; pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <!-- ë©”ë‰´ -->
    <div id="menu">
      <h1>ğŸ§Ÿâ€â™‚ï¸ íƒ€ìì—°ìŠµ ê²Œì„</h1>
      <p>ë‹¤ê°€ì˜¤ëŠ” ì¢€ë¹„ë“¤ì˜ ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì„œ ì œê±°í•˜ì„¸ìš”!</p>
      <button class="difficulty-btn" onclick="startGame('easy')">ì‰¬ì›€</button>
      <button class="difficulty-btn" onclick="startGame('normal')">ë³´í†µ</button>
      <button class="difficulty-btn" onclick="startGame('hard')">ì–´ë ¤ì›€</button>
    </div>
    
    <!-- HUD -->
    <div id="hud" style="display: none;">
      <div id="score">ì ìˆ˜: 0</div>
      <div id="lives">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div>
      <div id="kills">ì œê±°: 0</div>
    </div>
    
    <!-- ì…ë ¥ì°½ -->
    <div id="inputArea" style="display: none;">
      <div id="inputLabel">ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”:</div>
      <input type="text" id="currentInput" placeholder="ì—¬ê¸°ì— ì…ë ¥..." autocomplete="off">
    </div>
    
    <!-- ê²Œì„ ì˜¤ë²„ -->
    <div id="gameOver">
      <h2>ê²Œì„ ì˜¤ë²„!</h2>
      <div id="finalStats">
        <div>ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span></div>
        <div>ì œê±°í•œ ì¢€ë¹„: <span id="finalKills">0</span>ë§ˆë¦¬</div>
        <div>ì •í™•ë„: <span id="accuracy">0</span>%</div>
      </div>
      <button id="restartBtn" onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
    </div>
    
    <!-- ì¡°ì‘ë²• -->
    <div id="instructions">
      í‚¤ë³´ë“œë¡œ ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì—¬ ì¢€ë¹„ë¥¼ ì œê±°í•˜ì„¸ìš”!
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    // ê²Œì„ ë³€ìˆ˜ë“¤
    let scene, camera, renderer, player, enemies = [];
    let gameState = 'menu'; // 'menu', 'playing', 'gameOver'
    let difficulty = 'normal';
    let score = 0, lives = 5, kills = 0, totalTyped = 0, correctTyped = 0;
    let currentInput = '';
    let enemySpawnTimer = 0;
    let gameStartTime = 0;
    
    // ë‚œì´ë„ë³„ ì„¤ì •
    const difficultySettings = {
      easy: {
        wordLength: [2, 3],
        spawnInterval: 3000,
        enemySpeed: 0.02,
        words: ['ì‚¬ê³¼', 'ë°”ë‚˜ë‚˜', 'ê³ ì–‘ì´', 'ê°•ì•„ì§€', 'ì±…ìƒ', 'ì˜ì', 'ì»µ', 'ë¬¼', 'ë¹µ', 'ìš°ìœ ', 'ê½ƒ', 'ë‚˜ë¬´', 'ì§‘', 'ë¬¸', 'ì°½ë¬¸', 'ë°©', 'ì¹¨ëŒ€', 'ì˜·', 'ì‹ ë°œ', 'ëª¨ì', 'ì¥ê°‘', 'ì‹œê³„', 'ì „í™”', 'í…”ë ˆë¹„ì „', 'ë¼ë””ì˜¤', 'ì±…', 'íœ', 'ì—°í•„', 'ì§€ìš°ê°œ', 'ê°€ë°©']
      },
      normal: {
        wordLength: [3, 4],
        spawnInterval: 2000,
        enemySpeed: 0.03,
        words: ['ì»´í“¨í„°', 'í‚¤ë³´ë“œ', 'í–„ë²„ê±°', 'í”¼ì', 'ì¹˜í‚¨', 'ë¼ë©´', 'ê¹€ì¹˜', 'ëœì¥', 'ê³ ì¶”ì¥', 'ë§ˆìš”ë„¤ì¦ˆ', 'ì¼€ì²©', 'ì†Œê¸ˆ', 'ì„¤íƒ•', 'í›„ì¶”', 'ì‹ì´ˆ', 'ê°„ì¥', 'ì°¸ê¸°ë¦„', 'ë“¤ê¸°ë¦„', 'ì˜¬ë¦¬ë¸Œìœ ', 'ë²„í„°', 'ì¹˜ì¦ˆ', 'ìš”êµ¬ë¥´íŠ¸', 'ì•„ì´ìŠ¤í¬ë¦¼', 'ì¼€ì´í¬', 'ì¿ í‚¤', 'ì‚¬íƒ•', 'ì´ˆì½œë¦¿', 'ê³¼ì', 'ìŒë£Œìˆ˜', 'ì£¼ìŠ¤']
      },
      hard: {
        wordLength: [4, 6],
        spawnInterval: 1500,
        enemySpeed: 0.04,
        words: ['íƒ€ìì—°ìŠµ', 'í”„ë¡œê·¸ë˜ë°', 'ì¸ê³µì§€ëŠ¥', 'ì•Œê³ ë¦¬ì¦˜', 'ë°ì´í„°ë² ì´ìŠ¤', 'ë„¤íŠ¸ì›Œí¬', 'ë³´ì•ˆì‹œìŠ¤í…œ', 'í´ë¼ìš°ë“œì»´í“¨íŒ…', 'ë¨¸ì‹ ëŸ¬ë‹', 'ë”¥ëŸ¬ë‹', 'ë¸”ë¡ì²´ì¸', 'ê°€ìƒí˜„ì‹¤', 'ì¦ê°•í˜„ì‹¤', 'ì‚¬ë¬¼ì¸í„°ë„·', 'ë¹…ë°ì´í„°', 'ì‚¬ì´ë²„ë³´ì•ˆ', 'ë””ì§€í„¸íŠ¸ëœìŠ¤í¬ë©”ì´ì…˜', 'ì‚¬ìš©ìê²½í—˜', 'ì¸í„°í˜ì´ìŠ¤', 'í”Œë«í¼', 'ì• í”Œë¦¬ì¼€ì´ì…˜', 'ì†Œí”„íŠ¸ì›¨ì–´', 'í•˜ë“œì›¨ì–´', 'ìš´ì˜ì²´ì œ', 'í”„ë¡œê·¸ë˜ë°ì–¸ì–´', 'ê°œë°œí™˜ê²½', 'ë²„ì „ê´€ë¦¬', 'í…ŒìŠ¤íŠ¸ì½”ë“œ', 'ë°°í¬ì‹œìŠ¤í…œ', 'ëª¨ë‹ˆí„°ë§']
      }
    };
    
    // Three.js ì´ˆê¸°í™”
    function initThreeJS() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2c3e50);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 15, 20);
      camera.lookAt(0, 0, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('gameContainer').appendChild(renderer.domElement);
      
      // ì¡°ëª… ì„¤ì •
      const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);
      
      // ë°”ë‹¥ ìƒì„±
      const groundGeometry = new THREE.CircleGeometry(30, 32);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x34495e });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // í”Œë ˆì´ì–´ ìƒì„± (ì¤‘ì•™ì— ê³ ì •)
      const playerGeometry = new THREE.CylinderGeometry(1, 1, 3, 8);
      const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x3498db });
      player = new THREE.Mesh(playerGeometry, playerMaterial);
      player.position.set(0, 1.5, 0);
      player.castShadow = true;
      scene.add(player);
      
      // í”Œë ˆì´ì–´ ìœ„ì— í‘œì‹œ
      const playerTopGeometry = new THREE.SphereGeometry(0.8, 8, 8);
      const playerTopMaterial = new THREE.MeshLambertMaterial({ color: 0xe74c3c });
      const playerTop = new THREE.Mesh(playerTopGeometry, playerTopMaterial);
      playerTop.position.set(0, 2.5, 0);
      playerTop.castShadow = true;
      player.add(playerTop);
    }
    
    // ë‹¨ì–´ í…ìŠ¤ì²˜ ìƒì„±
    function createWordTexture(word) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      
      // ë°°ê²½
      context.fillStyle = 'rgba(0, 0, 0, 0.8)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // í…Œë‘ë¦¬
      context.strokeStyle = '#4ecdc4';
      context.lineWidth = 3;
      context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      
      // í…ìŠ¤íŠ¸
      context.fillStyle = '#ffffff';
      context.font = 'bold 24px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(word, canvas.width / 2, canvas.height / 2);
      
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }
    
    // ì  ìƒì„±
    function spawnEnemy() {
      const settings = difficultySettings[difficulty];
      const word = settings.words[Math.floor(Math.random() * settings.words.length)];
      
      // ì  ë©”ì‹œ ìƒì„±
      const enemyGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2, 6);
      const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0x8e44ad });
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      
      // ëœë¤ ìœ„ì¹˜ (ì› ë°–ì—ì„œ)
      const angle = Math.random() * Math.PI * 2;
      const distance = 25 + Math.random() * 10;
      enemy.position.set(
        Math.cos(angle) * distance,
        1,
        Math.sin(angle) * distance
      );
      
      enemy.castShadow = true;
      scene.add(enemy);
      
      // ë‹¨ì–´ ë¼ë²¨ ìƒì„±
      const wordTexture = createWordTexture(word);
      const wordMaterial = new THREE.SpriteMaterial({ map: wordTexture, transparent: true });
      const wordSprite = new THREE.Sprite(wordMaterial);
      wordSprite.position.set(0, 3, 0);
      wordSprite.scale.set(4, 1, 1);
      enemy.add(wordSprite);
      
      // ì  ë°ì´í„° ì €ì¥
      enemy.userData = {
        word: word,
        speed: settings.enemySpeed,
        angle: angle,
        distance: distance
      };
      
      enemies.push(enemy);
    }
    
    // ì  ì´ë™
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const data = enemy.userData;
        
        // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ ì´ë™
        const dx = -enemy.position.x;
        const dz = -enemy.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance > 0) {
          enemy.position.x += (dx / distance) * data.speed;
          enemy.position.z += (dz / distance) * data.speed;
        }
        
        // í”Œë ˆì´ì–´ì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸
        if (distance < 2) {
          // ìƒëª… ê°ì†Œ
          lives--;
          updateLivesDisplay();
          
          // ì  ì œê±°
          scene.remove(enemy);
          enemies.splice(i, 1);
          
          // ê²Œì„ ì˜¤ë²„ í™•ì¸
          if (lives <= 0) {
            endGame();
            return;
          }
        }
      }
    }
    
    // ì…ë ¥ ì²˜ë¦¬
    function handleInput() {
      const inputField = document.getElementById('currentInput');
      currentInput = inputField.value;
      
      // ì ë“¤ê³¼ ë§¤ì¹­ í™•ì¸
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.userData.word === currentInput) {
          // ì  ì œê±°
          scene.remove(enemy);
          enemies.splice(i, 1);
          
          // ì ìˆ˜ ì¦ê°€
          score += 10;
          kills++;
          correctTyped++;
          totalTyped++;
          
          updateHUD();
          
          // ì…ë ¥ì°½ ì´ˆê¸°í™”
          inputField.value = '';
          currentInput = '';
          break;
        }
      }
    }
    
    // HUD ì—…ë°ì´íŠ¸
    function updateHUD() {
      document.getElementById('score').textContent = `ì ìˆ˜: ${score}`;
      document.getElementById('kills').textContent = `ì œê±°: ${kills}`;
    }
    
    function updateLivesDisplay() {
      let hearts = '';
      for (let i = 0; i < 5; i++) {
        hearts += i < lives ? 'â¤ï¸' : 'ğŸ¤';
      }
      document.getElementById('lives').textContent = hearts;
    }
    
    // ê²Œì„ ì‹œì‘
    function startGame(diff) {
      difficulty = diff;
      gameState = 'playing';
      score = 0;
      lives = 5;
      kills = 0;
      totalTyped = 0;
      correctTyped = 0;
      enemySpawnTimer = 0;
      gameStartTime = Date.now();
      
      // ê¸°ì¡´ ì ë“¤ ì œê±°
      enemies.forEach(enemy => scene.remove(enemy));
      enemies = [];
      
      // UI ì „í™˜
      document.getElementById('menu').style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
      document.getElementById('inputArea').style.display = 'block';
      document.getElementById('gameOver').style.display = 'none';
      
      updateHUD();
      updateLivesDisplay();
      
      // ì…ë ¥ì°½ í¬ì»¤ìŠ¤
      document.getElementById('currentInput').focus();
    }
    
    // ê²Œì„ ì¢…ë£Œ
    function endGame() {
      gameState = 'gameOver';
      
      // ìµœì¢… í†µê³„ ê³„ì‚°
      const accuracy = totalTyped > 0 ? Math.round((correctTyped / totalTyped) * 100) : 0;
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalKills').textContent = kills;
      document.getElementById('accuracy').textContent = accuracy;
      
      // UI ì „í™˜
      document.getElementById('hud').style.display = 'none';
      document.getElementById('inputArea').style.display = 'none';
      document.getElementById('gameOver').style.display = 'flex';
    }
    
    // ê²Œì„ ì¬ì‹œì‘
    function restartGame() {
      gameState = 'menu';
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('gameOver').style.display = 'none';
    }
    
    // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
    function animate() {
      requestAnimationFrame(animate);
      
      if (gameState === 'playing') {
        // ì  ìƒì„±
        enemySpawnTimer += 16; // 60fps ê¸°ì¤€
        if (enemySpawnTimer >= difficultySettings[difficulty].spawnInterval) {
          spawnEnemy();
          enemySpawnTimer = 0;
        }
        
        // ì  ì´ë™
        updateEnemies();
        
        // í”Œë ˆì´ì–´ íšŒì „ (ì‹œê°ì  íš¨ê³¼)
        player.rotation.y += 0.01;
      }
      
      renderer.render(scene, camera);
    }
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    document.getElementById('currentInput').addEventListener('input', handleInput);
    document.getElementById('currentInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        handleInput();
        this.value = '';
        currentInput = '';
      }
    });
    
    // ì°½ í¬ê¸° ì¡°ì •
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ì´ˆê¸°í™” ë° ì‹œì‘
    initThreeJS();
    animate();
  </script>
</body>
</html>
